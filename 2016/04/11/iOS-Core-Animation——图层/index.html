<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>iOS Core Animation——图层 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Core Animation 演变自Layer Kit，是一个复合引擎，负责组合屏幕上不同的可视内容，内容是被分解成独立的图层，存储在图层树的体系之中。于是这个树形成了UIKit以及iOS应用程序当中你所能在屏幕上看见的一切的基础。">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS Core Animation——图层">
<meta property="og:url" content="http://yoursite.com/2016/04/11/iOS-Core-Animation——图层/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Core Animation 演变自Layer Kit，是一个复合引擎，负责组合屏幕上不同的可视内容，内容是被分解成独立的图层，存储在图层树的体系之中。于是这个树形成了UIKit以及iOS应用程序当中你所能在屏幕上看见的一切的基础。">
<meta property="og:updated_time" content="2016-04-11T06:09:02.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS Core Animation——图层">
<meta name="twitter:description" content="Core Animation 演变自Layer Kit，是一个复合引擎，负责组合屏幕上不同的可视内容，内容是被分解成独立的图层，存储在图层树的体系之中。于是这个树形成了UIKit以及iOS应用程序当中你所能在屏幕上看见的一切的基础。">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="null" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">John</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>標籤</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Alanmess" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/iOS/" style="font-size: 10px;">iOS</a> <a href="/tags/主题/" style="font-size: 10px;">主题</a>
					</div>
				</section>
				
				
				

				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">John</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="null" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">John</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Alanmess" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-iOS-Core-Animation——图层" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/11/iOS-Core-Animation——图层/" class="article-date">
  	<time datetime="2016-04-11T06:09:02.000Z" itemprop="datePublished">2016-04-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      iOS Core Animation——图层
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/主题/">主题</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>Core Animation 演变自Layer Kit，是一个复合引擎，负责组合屏幕上不同的可视内容，内容是被分解成独立的图层，存储在图层树的体系之中。于是这个树形成了<code>UIKit</code>以及iOS应用程序当中你所能在屏幕上看见的一切的基础。<br><a id="more"></a></p>
</blockquote>
<h3 id="u4E00_u3001_u56FE_u5C42_u6811"><a href="#u4E00_u3001_u56FE_u5C42_u6811" class="headerlink" title="一、图层树"></a>一、图层树</h3><h5 id="1-1_u56FE_u5C42_u4E0E_u89C6_u56FE"><a href="#1-1_u56FE_u5C42_u4E0E_u89C6_u56FE" class="headerlink" title="1.1图层与视图"></a>1.1图层与视图</h5><p>1.<code>UIView</code></p>
<p>一个视图就是在屏幕上显示的一个矩形块（比如图片，文字或者视频），它能够拦截类似于鼠标点击或者触摸手势等用户输入。视图在层级关系中可以互相嵌套，一个视图可以管理它的所有子视图的位置。</p>
<ul>
<li>可以处理触摸事件</li>
<li>支持基于Core Graphics绘图</li>
<li>做放射变化(例如旋转或者缩放)</li>
<li>简单的类似于滑动或者渐变的动画</li>
</ul>
<p>2.<code>CALayer</code></p>
<p>概念上于UIView类似，同样也是一些被层级关系树管理的矩形块，同样可以包含一些内容(图片、文本或背景色)，管理子图层的位置。它们有一些属性和方法用来做动画和变换。</p>
<p>与UIView不同的是CALayer不处理用户的交互，CALayer并不清楚具体的响应链(iOS通过视图层级关系用来传送触摸事件的机制)，于是它并不能够响应事件，即使它提供了一些方法来判断是否一个触点在图层的范围之内。</p>
<p>3.平行的层级关系</p>
<p>每一个UIView都有一个CALayer实例的图层属性(backing layer)，视图的职责是创建并管理这个图层，以确保当子视图在层级关系中添加或移除时，他们关联的图层也同样在对应的层级关系树中有相同的操作。</p>
<p>实际上UIView关联的图层才是真正用来在屏幕上显示和做动画的，UIView仅仅是对它的一个封装，提供了一些iOS类似于处理触摸的具体功能，以及Core Animation底层方法的高级接口。</p>
<p>UIView和CALayer的职责分离：</p>
<p>绘图、布局、动画，把这种功能的逻辑分开应用到独立的Core Animation框架，苹果就能够在iOS和Mac OS之间共享代码，使得开发更为便捷。</p>
<p>实际上，这里并不是两个层级关系，而是四个，每一个都扮演不同的角色，除了视图层级和图层树之外，还存在呈现树和渲染树。</p>
<h5 id="1-2_u56FE_u5C42_u7684_u80FD_u529B"><a href="#1-2_u56FE_u5C42_u7684_u80FD_u529B" class="headerlink" title="1.2图层的能力"></a>1.2图层的能力</h5><p>UIView的高级API间接地使得动画变得简单，但缺乏灵活性，CALayer特有的功能：</p>
<ul>
<li>阴影、圆角、带颜色的边框</li>
<li>3D变换</li>
<li>非矩形范围</li>
<li>透明遮罩</li>
<li>多级非线性动画</li>
</ul>
<h3 id="u4E8C_u3001_u5BC4_u5BBF_u56FE"><a href="#u4E8C_u3001_u5BC4_u5BBF_u56FE" class="headerlink" title="二、寄宿图"></a>二、寄宿图</h3><p>图层中包含的图</p>
<h5 id="2-1_contents_u5C5E_u6027"><a href="#2-1_contents_u5C5E_u6027" class="headerlink" title="2.1 contents属性"></a>2.1 contents属性</h5><p>contents是CALayer的一个id类型属性，理论上可以赋任何值，但如果不是CGImage，图层将是空白的；</p>
<p>contents这个奇怪的表现是由MAC OS得历史原因造成的；在Mac OS上，这个属性对CGImage和NSImage类型的值都起作用，但在iOS上，UIImage赋值只能得到空白的图层。</p>
<p>contents真正的赋值类型应该是CGImageRef(指向CGImage结构的指针)，UIImage的CGImage属性返回一个CGImageRef，如果直接赋给contents会编译错误，因为CGImageRef不是一个真正的Cocoa对象，而是一个Core Foundation类型，需要通过bridged关键字转换，如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layer.contents = (__bridged id)image.CGImage;</span><br></pre></td></tr></table></figure>
<p><strong>contentGravity</strong></p>
<p>该属性决定了内容在图层CALayer的边界中怎么对齐</p>
<p><strong>contentsScale</strong></p>
<p>该属性定义了寄宿图的像素尺寸和视图大小的比例，默认为1.0；</p>
<p>如果contentsScale设置为1.0，将会以每个点1个像素绘制图片，如果设置为2.0，则会以每个点2个像素绘制图片，这就是我们熟知的Retina屏幕。</p>
<p>当用代码的方式来处理寄宿图的时候，一定要记住要手动设置图层的contentsScale属性，否则，你的额突破在Retaina设备上就显示的不正确啦，如下：</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layer.contentsScale = <span class="string">[UIScreen mainScreen]</span>.scale;</span><br></pre></td></tr></table></figure>
<p><strong>maskToBounds</strong></p>
<p>UIView有一个叫<code>clipsToBounds</code>的属性决定是否显示超出边界的内容，CALayer对应的属性叫做<code>masksToBounds</code>。</p>
<p><strong>contentsRect</strong></p>
<p>该属性允许我们在图层边框里显示寄宿图的一个子域。这涉及到图片是如何显示和拉伸的，所以要比contentsGravity灵活多了。</p>
<p>和bounds、frame不同，contentsRect不是按点来计算，它使用了单位坐标，单位坐标是指0到1之间，是一个相对值。所以他们是相对于寄宿图的尺寸的。contentsRect默认为{0,0,1,1}。</p>
<p>iOS使用了以下的坐标系统：</p>
<ul>
<li>点——点就像虚拟的像素，也被称作逻辑像素。在标准设备上，一个点就是一个像素，但在Retina设备上，一个点等于2*2个像素。iOS用点作为屏幕的坐标测算体系就是为了在Retina设备和普通设备上能有一致的视觉效果。</li>
<li>像素——物理像素坐标并不会用了屏幕布局，但是仍然与图片有相对关系。UIImage是一个屏幕分辨率的解决方案，所以指定点来度量大小。但是一些底层的图片表示如CGImage就会使用像素，所以在Retina设备和普通设备上，他们表现出来了不同的大小。</li>
<li>单位——对于与图片大小或是图层边界相关的显示，单位坐标是一个方便的度量方式，当大小改变的时候，也不需要再次调整。</li>
</ul>
<p><strong>contentsCenter</strong></p>
<p>该属性定义了一个固定的边框和一个在图层上可拉伸的区域。改变contentsCenter的值并不会影响到寄宿图的显示，除非这个图层的大小改变了，你才看的到效果。</p>
<p>默认情况下，contentsCenter为{0,0,1,1}，这意味着如果大小(由contentsGravity决定)改变了，那么寄宿图将会均匀地拉伸开。</p>
<h5 id="2-2_Custom_Drawing"><a href="#2-2_Custom_Drawing" class="headerlink" title="2.2 Custom Drawing"></a>2.2 Custom Drawing</h5><p>给contents赋CGImage的值不是唯一的设置寄宿图的方法。我们也可以直接用CoreGraphics直接绘制寄宿图。能够通过继承UIView并实现<code>-drawRect：</code>方法来自定义绘制。</p>
<blockquote>
<p>-drawRect:方法没有默认的实现，因为对于UIView来说，寄宿图并不是必须的，它不在意那到底是单调的颜色还是有一个图片的实例。如果UIView检测到-drawRect：方法被调用了，它就会为视图分配一个寄宿图，这个寄宿图的像素尺寸等于视图大小乘以contentScale的值。</p>
</blockquote>
<p>如果你不需要寄宿图，那就不要创建这个方法，这会造成CPU资源和内存的浪费，这也是为什么苹果建议：如果没有自定义绘制的任务就不要在子类中写一个空的-drawRect：方法。</p>
<p>当视图在屏幕上出现的时候，-drawRect方法就会被自动调用。-drawRect方法里面的代码利用Core Graphics去绘制一个寄宿图，然后内容就会被缓存起来直到它需要被更新(通常是因为开发者调用了-setNeedsDisplay方法，尽管影响到表现效果的属性值被更改时，一些视图类型会被自动重绘，如bounds属性)。虽然<code>-drawRect</code>方法是一个UIView方法，事实上都是底层的CALayer安排了重绘工作和保存了因此产生的图片。</p>
<h3 id="u4E09_u3001_u56FE_u5C42_u51E0_u4F55_u5B66"><a href="#u4E09_u3001_u56FE_u5C42_u51E0_u4F55_u5B66" class="headerlink" title="三、图层几何学"></a>三、图层几何学</h3><h5 id="3-1_u5E03_u5C40"><a href="#3-1_u5E03_u5C40" class="headerlink" title="3.1布局"></a>3.1布局</h5><p>布局属性：UIView(frame、bounds、center)  CALayer(frame、bounds、position)</p>
<p>frame：图层的外部坐标(也就是在父图层上占据的空间)</p>
<p>bounds：内部坐标({0,0}通常是图层的左上角)</p>
<p>position/center：相对于父图层anchorPoint所在的位置</p>
<p>视图的frame、bounds和center属性仅仅是存取方法，当操纵视图的frame时，实际上是在改变位于视图下方的CALayer的frame，不能够独立于图层之外改变视图的frame。</p>
<p>对于视图或图层来说，frame并不是一个非常清晰的属性，它其实是一个虚拟属性，是根据bounds、position、transform计算而来，所以当其中任何一个值发生改变，frame都会变化；相反，改变frame的值同样会影响到他们当中的值。</p>
<blockquote>
<p>记住当对图层做变换时，比如旋转或缩放，frame实际上代表了覆盖在图层旋转之后的整个轴对齐的矩形区域，也就是说frame的宽高可能和bounds的宽高不再一致。</p>
</blockquote>
<h5 id="3-2_u951A_u70B9"><a href="#3-2_u951A_u70B9" class="headerlink" title="3.2锚点"></a>3.2锚点</h5><blockquote>
<p>视图的center属性和图层的position属性都是指定了anchorPoint相对于父图层的位置。图层的anchorPoint通过position来控制它的frame位置，你可以认为anchorPoint是用来移动图层的把柄。</p>
</blockquote>
<p>position是layer中的anchorPoint点在superLayer中的位置。</p>
<h5 id="3-3_u5750_u6807_u7CFB"><a href="#3-3_u5750_u6807_u7CFB" class="headerlink" title="3.3坐标系"></a>3.3坐标系</h5><p>和视图一样，图层在图层树中也是相对于父图层按层级关系放置，一个图层的position依赖于它父图层的bounds，如果父图层发生了移动，它的所有子图层也会跟着移动。</p>
<p>CALayer给不同坐标系之间的图层转换提供了一些工具类方法：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">- <span class="params">(<span class="variable">CGPoint</span>)</span>convertPoint:<span class="params">(<span class="variable">CGPoint</span>)</span>point fromLayer:<span class="params">(<span class="variable">CALayer</span> *)</span>layer;</span><br><span class="line">- <span class="params">(<span class="variable">CGPoint</span>)</span>convertPoint:<span class="params">(<span class="variable">CGPoint</span>)</span>point toLayer:<span class="params">(<span class="variable">CALayer</span> *)</span>layer;</span><br><span class="line">- <span class="params">(<span class="variable">CGRect</span>)</span>convertRect:<span class="params">(<span class="variable">CGRect</span>)</span>rect fromLayer:<span class="params">(<span class="variable">CALayer</span> *)</span>layer;</span><br><span class="line">- <span class="params">(<span class="variable">CGRect</span>)</span>convertRect:<span class="params">(<span class="variable">CGRect</span>)</span>rect toLayer:<span class="params">(<span class="variable">CALayer</span> *)</span>layer;</span></span><br></pre></td></tr></table></figure>
<p><strong>Z坐标轴</strong></p>
<p>和UIView严格的二维坐标系不同，CALayer存在一个三维空间当中。除了position和anchorPoint属性外，CALayer还有另外两个属性，zPosition和anchorPointZ，二者都是在Z轴上描述图层位置的浮点类型。</p>
<p>zPosition属性在大多数情况下并不常用。CATransform3D在三维空间移动和旋转图层外，最实用的功能就是改变图层的显示顺序。</p>
<h5 id="3-4_Hit_Testing"><a href="#3-4_Hit_Testing" class="headerlink" title="3.4 Hit Testing"></a>3.4 Hit Testing</h5><p>CALayer并不关心任何响应链事件，所以不能直接处理触摸事件或者手势。但是它有一系列的方法帮你处理事件：<code>-containsPoint:</code>和<code>-hitTest:</code>。</p>
<blockquote>
<p>-hitTest方法同样接受一个CGPoint类型参数，而不是BOOL类型，它返回图层本身，或者包含这个坐标点的叶子节点图层。</p>
</blockquote>
<p>当调用图层的-hitTest方法时，测算的顺序严格依赖于图层树当中的图层顺序(和UIView处理事件类似)。之前提到的zPosition属性可以明显改变屏幕上图层的顺序，但不能改变事件传递的顺序。</p>
<p>这意味着如果改变了图层的z轴顺序，你会发现将不能够检测到最前方的视图点击事件，这是因为被另一个图层遮盖住了，虽然它的zPosition值较小，但是图层树中的顺序考前。</p>
<h5 id="3-5_u81EA_u52A8_u5E03_u5C40"><a href="#3-5_u81EA_u52A8_u5E03_u5C40" class="headerlink" title="3.5自动布局"></a>3.5自动布局</h5><p>UIViewAutoresizingMask类型常量应用于当父视图改变尺寸的时候，相应UIView的frame也跟着更新的场景(通常用于横竖屏切换)。</p>
<p>当使用视图的时候，可以充分利用UIVIew类接口暴露出来的UIViewAutoresizingMask和NSLayoutConstraint API，但如果想随意控制CALayer的布局，就需要手工操作。最简单的方法就是使用CALayerDelegate如下函数：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">- <span class="params">(void)</span>layoutSublayerOfLayer:<span class="params">(<span class="variable">CALayer</span> *)</span>layer;</span></span><br></pre></td></tr></table></figure>
<p>当图层的bounds发生改变，或者图层的-setNeedsLayout方法被调用时，这个函数将会被执行。这使得你可以手动地重写摆放或者重写调整子图层的大小，但是不能像UIView的autoresizingMask和constraints属性做到自适应屏幕旋转。</p>
<p>这也是为什么最好使用视图而不是单独的图层来构建应用程序的另一个重要原因之一。</p>
<h3 id="u56DB_u3001_u89C6_u89C9_u6548_u679C"><a href="#u56DB_u3001_u89C6_u89C9_u6548_u679C" class="headerlink" title="四、视觉效果"></a>四、视觉效果</h3><h5 id="4-1_u5706_u89D2"><a href="#4-1_u5706_u89D2" class="headerlink" title="4.1圆角"></a>4.1圆角</h5><p>CALayer有一个叫做cornerRadius的属性控制着图层角的曲率。默认情况下，这个曲率只影响背景颜色而不影响背景图片或是子图层。不过，如果把masksToBounds设置成YES的话，图层里面的所有东西都会被截取。</p>
<h5 id="4-2_u56FE_u5C42_u8FB9_u6846"><a href="#4-2_u56FE_u5C42_u8FB9_u6846" class="headerlink" title="4.2图层边框"></a>4.2图层边框</h5><p>borderWidth和borderColor</p>
<p>边框是绘制在图层边界里面，而且在所有子内容之前，也在子图层之前。</p>
<h5 id="4-3_u56FE_u5C42_u9634_u5F71"><a href="#4-3_u56FE_u5C42_u9634_u5F71" class="headerlink" title="4.3图层阴影"></a>4.3图层阴影</h5><p>阴影可以达到图层深度暗示的效果，也能够用来强调正在显示的图层和优先级。</p>
<p>给<code>shadowOpacity</code>属性一个大于默认值0的值，阴影就可以显示在任意图层之下。若要改动阴影的表现，你可以使用CALayer的另外三个属性：<code>shadowColor</code> <code>shdowOffset</code> <code>shadowRadius</code></p>
<p><strong>阴影裁剪</strong></p>
<p>和图层边框不同，图层的阴影继承自内容的外形，而不是根据边界和角半径来确定。为了计算出阴影的形状，Core Animation会将寄宿图(包括子视图)考虑在内，然后通过这些来完美搭配图层形状从而创建一个阴影。</p>
<p><strong>shadowPath属性</strong></p>
<p>我们已经知道图层阴影并不总是方的，而是从图层内容的形状继承而来。这看上去不错，但是实时计算阴影也是一个非常消耗资源的，尤其是图层有多个子图层，每个图层还有一个有透明效果的寄宿图的时候。</p>
<p>如果你事先知道你的阴影形状会是什么样子的，你可以通过指定一个<code>shadowPath</code>来提高性能。shadowPath是一个CGPathRef类型(一个指向CGPath的指针)。CGPath是一个Core Graphics对象，用来指定任意的一个矢量图形。我们可以通过这个属性单独于图层形状之外指定阴影的形状。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGMutablePathRef</span> path = <span class="built_in">CGPathCreateMutable</span>();</span><br><span class="line"><span class="built_in">CGPathAddRect</span>(path, <span class="literal">NULL</span>, layer<span class="variable">.bounds</span>);</span><br><span class="line">layer<span class="variable">.shadowPath</span> = path;</span><br><span class="line"><span class="built_in">CGPathRelease</span>(path);</span><br></pre></td></tr></table></figure>
<p>如果是一个矩形或者是圆，用CGPath会相当简单明了。但是如果是更加复杂一点的图形，UIBezierPath类会更合适，它是一个由UIKit提供的在CGPath基础上的Objective-C包装类。</p>
<h5 id="4-4_u56FE_u5C42_u8499_u7248"><a href="#4-4_u56FE_u5C42_u8499_u7248" class="headerlink" title="4.4图层蒙版"></a>4.4图层蒙版</h5><p>通过<code>masksToBounds</code>属性，我们可以沿边界裁剪图形；通过<code>cornerRadius</code>属性可以设定一个圆角。但是有时候你希望展现的内容不是在一个矩形或圆角矩形，比如，你想展示一个有星形框架的图片，又或者想让一些古卷文字慢慢渐变成背景色，而不是一个突兀的边界。</p>
<p>使用一个32位有alpha通道的png图片通常是创建一个无矩形视图最方便的方法，你可以给它指定一个透明蒙版来实现。但是这个方法不能让你以编码的方式动态的生成蒙版，也不能让子图层或子视图裁剪成同样的形状。</p>
<p>CALayer有一个叫做mask的属性可以解决这个问题。这个属性本身就是个CALayer类型，有和其他图层一样的绘制和布局属性。它类似于一个子图层，相对于父图层(即拥有该属性的图层)布局，但是它却不是一个普通的子图层。不同于那些绘制在父图层中的子图层，mask图层定义了父图层的部分可见区域。</p>
<p>mask图层的color属性是无关紧要的，真正重要的是图层的轮廓。mask属性就像是一个饼干切割机，mask图层实心的部分会被保留下来，其他的则会被抛弃。</p>
<p>如果mask图层比父图层要小，只有在mask图层里面的内容才是它关心的，除此以外的一切都会被隐藏起来。</p>
<p>CALayer蒙版图层真正厉害的地方在于蒙版图不局限于静态图。任何有图层构成的都可以作为mask属性，这意味着你的蒙版可以通过代码甚至动画实时生成。</p>
<h5 id="4-5_u62C9_u4F38_u8FC7_u6EE4"><a href="#4-5_u62C9_u4F38_u8FC7_u6EE4" class="headerlink" title="4.5拉伸过滤"></a>4.5拉伸过滤</h5><p>当我们视图显示一个图片的时候，都应该正确地显示这个图片(意即：以正确的比例和正确的1：1像素显示在屏幕上)。原因如下：</p>
<ul>
<li>能够显示最好的画质，像素既没有被压缩也没有被拉伸</li>
<li>能更好的使用内存，因为这就是所有你要存储的东西</li>
<li>最好的性能表现，CPU不需要为此额外的计算</li>
</ul>
<p>不过有时候，显示一个非真实大小的图片确实是我们需要的效果。比方说一个头像或是图片的缩略图，再比方说一个可以被拖曳和伸缩的大图。这些情况下，为同一图片的不同大小存储不同的图片显得又不切实际。</p>
<p>当图片需要显示不同的大小的时候，有一种叫做拉伸过滤的算法就起到了作用。它作用于原图的像素上并根据需要生成新的像素显示在屏幕上。</p>
<p>事实上，重绘图片大小也没有一个统一的通用算法。这取决于需要拉伸的内容，放大或是缩小的需求等这些因素。CALayer为此提供了三种拉伸过滤方法，如下：</p>
<ul>
<li>kCAFilterLinear</li>
<li>kCAFilterNearest</li>
<li>kCAFilterTrilinear</li>
</ul>
<p>minification(缩小图片)和magnification(放大图片)默认的过滤器都是<code>kCAFilterLinear</code>，这个过滤器采用双线性滤波算法，它在大多数情况下都表现良好。双线性滤波算法通过对多个像素取样最终生成新的值，得到一个平滑的表现不错的拉伸。但是放大倍数比较大的时候图片就模糊不清了。</p>
<p><code>kCAFilterTrilinear</code>和<code>kCAFilterLinear</code>非常相似，大部分情况下二者都看不出来有什么差别。但是，较双线性滤波算法而言，三线性滤波算法存储了多个大小情况下的图片(也叫多重贴图)，并三维取样，同时结合大图和小图的存储进而得到最后的结果。</p>
<p>这个方法的好处在于算法能够从一系列已经接近于最终大小的图片中得到想要的结果，也就是说不要对很多像素同步取样。这不仅提高了性能，也避免了小概率因舍入错误引起的取样失灵的问题。</p>
<p><code>kCAFilterNearest</code>是一种比较武断的方法。从名字不难看出，这个算法(也叫最近过滤)就是取样最近的单像素点而不管其他的颜色。这样做非常快，也不会使图片模糊。但是，最明显的效果就是，会使得压缩图片更糟，图片放大之后也显得块状或是马赛克严重。</p>
<p>总的来说，对于比较小的图或是差异特别明显，极少线性的大图，最近过滤算法会保留这种差异明显的特质以呈现更好的结果。但是对于大多数的图尤其是有很多斜线或是曲线轮廓的图片来说，最近过滤算法会导致更差的结果。换句话说，线性过滤保留了形状，最近过滤则保留了像素的差异。</p>
<h5 id="4-6_u7EC4_u900F_u660E"><a href="#4-6_u7EC4_u900F_u660E" class="headerlink" title="4.6组透明"></a>4.6组透明</h5><p>UIView有一个叫做<code>alpha</code>的属性来确定视图的透明度。CALayer有一个等同的属性叫做<code>opacity</code>，这两个属性都是影响子层级的。也就是说，如果你给一个图层设置了opacity属性，那它的子图层都会受此影响。</p>
<p>当你显示一个50%透明度的图层时，图层的每个像素都会一半显示自己的颜色，另一半显示图层下面的颜色。这是正常的透明度的表现。但是如果图层包含一个同样显示50%透明的子图层时，你所看到的视图，50%来自子视图，25%来自图层本身的颜色，另外25%则来自背景色。(透明度混合叠加后变成75%)</p>
<blockquote>
<p>理想状况下，当你设置了一个图层的透明度，你希望它包含的整个图层树像一个整体一样的透明效果。你可以通过设置info.plist文件中的<code>UIViewGroupOpacity</code>为YES来达到这个效果，但是这个设置会影响到这个应用，整个app可能会受到不良影响。如果<code>UIViewGroupOpacity</code>并未设置，iOS6和以前的版本会默认为NO。</p>
</blockquote>
<p>另一个方法就是，你可以设置CALayer的一个叫做<code>shouldRasterize</code>属性来实现组透明的效果，如果它被设置为YES，在应用透明度之前，图层及其子图层都会被整合成一个整体的图片，这样就没有透明度混合的问题了。</p>
<p>为了启用<code>shouldRasterize属性</code>，我们设置了图层的<code>rasterizationScale</code>属性。默认情况下，所有图层拉伸都是1.0，所以你使用了<code>shouldRasterize</code>属性，你就要确保你设置了<code>rasterizationScale</code>属性去匹配屏幕，以防止出现Retina屏幕像素化得问题。</p>
<h3 id="u4E94_u3001_u53D8_u6362"><a href="#u4E94_u3001_u53D8_u6362" class="headerlink" title="五、变换"></a>五、变换</h3><h5 id="5-1_u4EFF_u5C04_u53D8_u6362"><a href="#5-1_u4EFF_u5C04_u53D8_u6362" class="headerlink" title="5.1仿射变换"></a>5.1仿射变换</h5><p>实际上UIView的transform属性是一个<code>CGAffineTransform</code>类型，用于在二维空间做旋转，缩放和平移。<code>CGAffineTransform</code>是一个可以和二维空间向量(如CGPoint)做乘法的3x2的矩阵。</p>
<p>当对图层应用变换矩阵，图层矩形内的每一个点都被相应地做变换，从而形成一个新的四边形的形状。<code>CGAffineTransform</code>中的仿射的意思是无论变换矩阵用什么值，图层中平行的两条线在变换之后仍然保持平行。</p>
<p><strong>创建一个CGAffineTransform</strong></p>
<p>Core Graphics提供了一系列函数，对完全没有数学基础的开发者也能够简单地做一些变换。如下几个函数都创建了一个<code>CGAffineTransform</code>实例：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">CGAffineTransformMakeRotation</span><span class="params">(CGFloat angle)</span></span> <span class="comment">//旋转</span></span><br><span class="line"><span class="function"><span class="title">CGAffineTransformMakeScale</span><span class="params">(CGFloat sx, CGFloat sy)</span></span> <span class="comment">//缩放</span></span><br><span class="line"><span class="function"><span class="title">CGAffineTransformMakeTranslation</span><span class="params">(CGFloat tx, CGFloat ty)</span></span>  <span class="comment">//平移</span></span><br></pre></td></tr></table></figure>
<p>UIView可以通过设置<code>transform</code>属性做变换，但实际上它只是封装了内部图层的变换。</p>
<p>CALayer同样也有一个<code>transform</code>属性，但它的类型是<code>CATransform3D</code>，而不是<code>CGAffineTransform</code>。CALayer对应于UIView的<code>transform</code>属性叫做<code>affineTransform</code>。</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CGAffineTransform transform = CGAffineTransformMakeRotation(M_PI_4)<span class="comment">;</span></span><br><span class="line">layer.affineTransform = transform<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><strong>混合变换</strong></p>
<p>Core Graphics提供了一系列的函数可以在一个变换的基础上做更深层次的变换，如果做一个既要缩放又要旋转的变换，这就会非常有用了。例如下面几个函数：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGAffineTransformRotate</span>(<span class="built_in">CGAffineTransform</span> t, <span class="built_in">CGFloat</span> angle)</span><br><span class="line"><span class="built_in">CGAffineTransformScale</span>(<span class="built_in">CGAffineTransform</span> t, <span class="built_in">CGFloat</span> sx, <span class="built_in">CGFloat</span> sy)</span><br><span class="line"><span class="built_in">CGAffineTransformTranslate</span>(<span class="built_in">CGAffineTransform</span> t, <span class="built_in">CGFloat</span> tx, <span class="built_in">CGFloat</span> ty)</span><br></pre></td></tr></table></figure>
<p>当操纵一个变换的时候，初始生成一个什么都不做的变换很重要——也就是创建一个<code>CGAffineTransform</code>类型的空值，矩阵论中称作单位矩阵，Core Graphics同样也提供了一个方便的常量：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGAffineTransformIdentity</span></span><br></pre></td></tr></table></figure>
<p>最后，如果需要混合两个已经存在的变换矩阵，就可以用如下方法，在两个变换的基础上创建一个新的变换：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGAffineTransformConcat</span>(<span class="built_in">CGAffineTransform</span> t1，<span class="built_in">CGAffineTransform</span> t2);</span><br></pre></td></tr></table></figure>
<p>例子：先缩小50%，再旋转30度，最后向右移动200个像素</p>
<figure class="highlight rsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CGAffineTransform <span class="built_in">transform</span> = CGAffineTransformIdentity;</span><br><span class="line"><span class="built_in">transform</span> = CGAffineTransformScale(<span class="built_in">transform</span>, <span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line"><span class="built_in">transform</span> = CGAffineTransformRotate(<span class="built_in">transform</span>, M_PI / <span class="number">180.0</span> * <span class="number">30.0</span>);</span><br><span class="line"><span class="built_in">transform</span> = CGAffineTransformTranslate(<span class="built_in">transform</span>, <span class="number">200</span>, <span class="number">0</span>);</span><br><span class="line">layer.affineTransform = <span class="built_in">transform</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：图片向右发生了平移，但并没有指定距离那么远(200像素)，另外它还有点向下发生了平移。原因在于当你按顺序做了变换，上一个变换的结果将会影响之后的变换，所以200像素的向右平移同样也被旋转了30度，缩小了50%，所以它实际上是斜向移动了100像素。</p>
<p>这意味着变换的顺序会影响最终的结果，也就是说旋转之后的平移和平移之后的旋转结果可能不同。</p>
</blockquote>
<h5 id="5-2_3D_u53D8_u6362"><a href="#5-2_3D_u53D8_u6362" class="headerlink" title="5.2 3D变换"></a>5.2 3D变换</h5><p>CG的前缀告诉我们，<code>CGAffineTransform</code>类型属于Core Graphics框架，Core Graphics实际上是一个严格意义上的2D绘图API，并且<code>CGAffineTransform</code>仅仅对2D变换有效。</p>
<p><code>transform</code>属性(<code>CATransform3D</code>类型)可以让图层在3D空间内移动或者旋转。</p>
<p>和<code>CGAffineTransform</code>类似，<code>CATransform3D</code>是一个可以在3维空间内做变换的4x4的矩阵。</p>
<p>和<code>CGAffineTransform</code>矩阵类似，Core Animation提供了一系列的方法用来创建和组合<code>CATransform3D</code>类型的矩阵，和Core Graphics的函数类似，但是3D的平移和旋转多了一个z参数，并且旋转函数除了angle之外多了xyz三个参数，分别决定了每个坐标轴方向上的旋转：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CATransform3DMakeRotation</span>(<span class="built_in">CGFloat</span> angel, <span class="built_in">CGFloat</span> x, <span class="built_in">CGFloat</span> y, <span class="built_in">CGFloat</span> z)</span><br><span class="line"><span class="built_in">CATransform3DMakeScale</span>(<span class="built_in">CGFloat</span> sx, <span class="built_in">CGFloat</span> sy, <span class="built_in">CGFloat</span> sz)</span><br><span class="line"><span class="built_in">CATransform3DMakeTranslation</span>(<span class="built_in">CGFloat</span> tx, <span class="built_in">CGFloat</span> ty, <span class="built_in">CGFloat</span> tz)</span><br></pre></td></tr></table></figure>
<p><strong>透视投影</strong></p>
<p>在真实世界中，当物体远离我们的时候，由于视角的原因看起来会变小，理论上说远离我们的视图的边要比靠近视角的边更短，但实际上并没有发生，而我们当前的视角是等距离的，也就是在3D变换中仍然保持平行，和之前提到的仿射变换类似。</p>
<p>在等距投影中，远处的物体和近处的物体保持同样的缩放比例，这种投影也有它自己的用处(例如建筑绘图，颠倒，和伪3D视频)，但当前我们并不需要。</p>
<p>为了做一些修正，我们需要引入<em>投影变换</em>(又称作z变换)来对除了旋转之外的变换矩阵做一些修改，Core Animation并没有给我们提供设置透视变换的函数，因此我们需要手动修改矩阵值，幸运的是，很简单：</p>
<p><code>CATransform3D</code>的透视效果通过一个矩阵中一个很简单的元素来控制：<code>m34</code>。<code>m34</code>用于按比例缩放X和Y值来计算到底要离视角多远。</p>
<p><code>m34</code>的默认值是0，我们可以通过设置<code>m34</code>为<code>-1.0/d</code>来应用透视效果，<code>d</code>代表了想象中视角相机和屏幕之间的距离，以像素为单位，那应该如何计算这个距离？实际上并不需要，大概估算一个就好了。</p>
<p>因为视角相机实际上并不存在，所以可以根据屏幕上的显示效果自由决定它的防止的位置。通常500-1000就已经很好 ，但对于特定的图层有时候更小或者更大的值会看起来更舒服，减少距离的值会增强透视效果，所以一个非常微小的值会让它看起来更加失真，然而一个非常大的值会让它基本失去透视效果；</p>
<figure class="highlight rsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CATAransform3D <span class="built_in">transform</span> = CATransform3DIdentity;</span><br><span class="line"><span class="built_in">transform</span>.m34 = -<span class="number">1.0</span> / <span class="number">500.0</span>;</span><br><span class="line"><span class="built_in">transform</span> = CATransform3DRotate(<span class="built_in">transform</span>, M_PI_4, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">layer.<span class="built_in">transform</span> = <span class="built_in">transform</span>;</span><br></pre></td></tr></table></figure>
<p><strong>灭点</strong></p>
<p>当在透视角绘图时，远离相机视角的物体将会变小变远，当远离一个极限距离，它们可能就缩成了一个点，于是所有的物体最后都汇聚消失在同一个点。</p>
<p>在现实中，这个点通常是视图的中心，于是为了在应用中创建拟真效果的透视，这个点应该聚在屏幕中点，或者至少是包含所有3D对象的视图中点。</p>
<p>Core Animation定义了这个点位于变换图层的anchorPoint(通常位于图层中心)。这就是说，当图层发生变换时，这个点永远位于图层变换之前的anchorPoint的位置。</p>
<p>当改变一个图层的position，你也改变了它的灭点，做3D变换的时候要时刻记住这一点，当你视图通过调整<code>m34</code>来让它更加有3D效果，应该首先把它放置于屏幕中央，然后通过平移来把它移动到指定位置(而不是直接改变它的position)，这样所有的3D图层都共享一个灭点。</p>
<p><strong>sublayerTransform属性</strong></p>
<p>如果有多个视图或者图层，每个都做3D变换，那就需要分别设置相同的<code>m34</code>值，并且确保在变换之前都在屏幕中央共享同一个position，如果用一个函数封装这些操作的确会更加方便，但仍然有限制(例如，你不能再Interface Builder中摆放视图)，这里有一个更好的方法。</p>
<p>CALayer有一个属性叫做<code>sublayerTransform</code>。它也是CATransform3D类型，但和对一个图层的变换不同，它影响到所有的子图层。这意味着你可以一次性对包含这些图层的容器做变换，于是所有的子图层都自动继承了这个变换方法。</p>
<p>相较而言，通过在一个地方设置透视变换会很方便，同时它会带来另一个显著的优势：灭点被设置在容器图层的中点，从而不需要再对子图层分别设置了。这意味着你可以随意使用position和frame来放置子图层，而不需要把它们放置在屏幕中点，然后为了保证统一的灭点用变换来做平移。</p>
<p><strong>背面</strong></p>
<p>我们既然可以在3D场景下旋转图层，那么也可以从背面去观察它。</p>
<p>图层是双面绘制的，反面显示的是正面的一个镜像图片。</p>
<p>但这并不是一个很好的特性，因为如果图层包含文本或者其他控件，那用户看到这些内容的镜像图片当然会感到困惑。另外也有可能造成资源的浪费：想象用这些图层形成一个不透明的固态立方体，既然永远都看不见这些图层的背面，那为什么浪费GPU来绘制它们呢？</p>
<p>CALayer有一个叫做<code>doubleSided</code>的属性来控制图层的背面是否要被绘制。这是一个BOOL类型，默认为YES，如果设置为NO，那么当图层正面从相机视角消失的时候，它将不会被绘制。</p>
<p><strong>扁平化图层</strong></p>
<p>如果对包含已经做过变换的图层的图层做反方向的变换将会发生什么呢？</p>
<p>由于尽管Core Animation图层存在于3D空间之内，但它们并不都存在同一个3D空间。每个图层的3D场景其实是扁平化的，当你从正面观察一个图层，看到的实际上由子图层创建的想象出来的3D场景，当你倾斜这个图层，你会发现实际上这个3D场景仅仅是被绘制在图层的表面。</p>
<p>类似的，当你在玩一个3D游戏，实际上仅仅是把屏幕做了一次倾斜，或许在游戏中可以看见有一面墙在你面前，但是倾斜屏幕并不能够看见墙里面的东西。所有场景里面绘制的东西并不会随着你观察它的角度改变而发生变化；图层也是同样的道理。</p>
<p>这使得用Core Animation创建非常复杂的3D场景变得十分困难。你不能够使用图层树去创建一个3D结构的层级关系——在相同场景下的任何3D表面必须和同样的图层保持一致，这是因为每个父视图都把它的子视图扁平化了。</p>
<p>至少当你用正常的CALayer的时候是这样，CALayer有一个叫做<code>CATransformLayer</code>的子类来解决这个问题。</p>
<h3 id="u516D_u3001_u4E13_u7528_u56FE_u5C42"><a href="#u516D_u3001_u4E13_u7528_u56FE_u5C42" class="headerlink" title="六、专用图层"></a>六、专用图层</h3><h5 id="6-1_CAShapeLayer"><a href="#6-1_CAShapeLayer" class="headerlink" title="6.1 CAShapeLayer"></a>6.1 CAShapeLayer</h5><p><code>CAShapeLayer</code>是一个通过矢量图形而不是bitmap来绘制的图层子类。你指定诸如颜色和线宽等属性，用CGPath来定义想要绘制的图形，最后CAShapeLayer就自动渲染出来了。当然，你也可以用Core Graphics直接向原始的CALayer的内容绘制一个路径，相比之下，使用<code>CAShapeLayer</code>有以下优点：</p>
<ul>
<li>渲染快速。CAShapeLayer使用了硬件加速，绘制同一图形会比用Core Graphics快很多。</li>
<li>高效使用内存。一个CAShapeLayer不需要像普通CALayer一样创建一个寄宿图形，所以无论有多大，都不会占用太多的内存。</li>
<li>不会被图层边界裁剪掉。一个CAShapeLayer可以在边界之外绘制。你的图层路径不会像在使用Core Graphics的普通CALayer一样被裁剪掉。</li>
<li>不会出现像素化。当你给CAShapeLayer做3D变换时，它不像一个有寄宿图的普通图层一样变得像素化。</li>
</ul>
<p><strong>创建一个CGPath</strong></p>
<p>CAShapeLayer可以用来绘制所有能够通过CGPath来表示的形状。这个形状不一定要闭合，图层路径也不一定要不可破，事实上你可以在一个图层上绘制好几个不同的形状。你可以控制一些属性比如<code>lineWidth</code>(线宽，用点表示单位)，<code>lineCap</code>(线条结尾的样子)，和<code>lineJoin</code>(线条之间的结合点的样子)；但是在图层层面你只有一次机会设置这些属性。如果你想用不同颜色或风格来绘制多个形状，就不得不为每个形状准备一个图层了。</p>
<p><strong>圆角</strong></p>
<p>我们创建圆角矩形其实就是人工绘制单独的直线和弧度，但是事实上UIBezierPath有自动绘制圆角矩形的构造方法，下面这段代码绘制了一个有三个圆角一个直角的矩形：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(<span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">CGSie</span> radii = <span class="built_in">CGSizeMake</span>(<span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">UIRectCorner</span> corners = <span class="built_in">UIRectCornerTopRight</span> | ...;</span><br><span class="line"><span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> beziePathWithRoundedRect:rect byRoundingCorners:corners cornerRadii:radii];</span><br></pre></td></tr></table></figure>
<p>我们可以通过这个图层路径绘制一个既有直角又有圆角的视图。如果我们想依照此图形来剪裁视图内容，我们可以吧CAShapeLayer作为视图的宿主图层，而不是添加一个子视图(图层蒙版知识相关)。</p>
<h5 id="6-2_CATextLayer"><a href="#6-2_CATextLayer" class="headerlink" title="6.2 CATextLayer"></a>6.2 CATextLayer</h5><p>如果你想在一个图层里面显示文字，完全可以借助图层代理直接将字符串使用Core Graphics写入图层的内容(这就是UILabel的精髓)。如果越过寄宿于图层的视图，直接在图层上操作，那其实相当繁琐。你要为每一个显示文字的图层创建一个能像图层代理一样工作的类，还有逻辑上判断哪个图层需要显示哪个字符串，更别提还有记录不同的字体、颜色等一系列乱七八糟的东西。</p>
<p>Core Animation提供了一个CALayer的子类CATextLayer，它以图层的形式包含了UILabel几乎所有的绘制特性，并且额外提供了一些新的特性。</p>
<p>同样，CATextLayer也要比UILabel渲染的快的多。很少有人知道iOS6及之前的版本，UILabel其实是通过WebKit来实现绘制的，这样就造成了当有很多文字的时候就会有极大的性能压力。而CATextLayer使用了Core Text，并且渲染的非常快。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CATextLayer</span> *textLayer = [<span class="built_in">CATextLayer</span> layer];</span><br><span class="line">textLayer<span class="variable">.frame</span> = view<span class="variable">.bounds</span>;</span><br><span class="line">[view<span class="variable">.layer</span> addSublayer:textLayer];</span><br><span class="line"></span><br><span class="line"><span class="comment">//set text attributes</span></span><br><span class="line">textLayer<span class="variable">.foregroundColor</span> = [<span class="built_in">UIColor</span> blackColor]<span class="variable">.CGColor</span>;</span><br><span class="line">textLayer<span class="variable">.alignmentMode</span> = K<span class="built_in">CAAlignmentJustified</span>;</span><br><span class="line">textLayer<span class="variable">.wrapped</span> = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//choose a font</span></span><br><span class="line"><span class="built_in">UIFont</span> *font = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//set layer font</span></span><br><span class="line"><span class="built_in">CFStringRef</span> fontName = (__bridge <span class="built_in">CFStringRef</span>)font<span class="variable">.fontName</span>;</span><br><span class="line"><span class="built_in">CGStringRef</span> fontRef = <span class="built_in">CGFontCreateWithFontName</span>(fontName);</span><br><span class="line">textLayer<span class="variable">.font</span> = fontRef;</span><br><span class="line">textLayer<span class="variable">.fontSize</span> = font<span class="variable">.pointSize</span>;</span><br><span class="line"><span class="built_in">CGFontRelease</span>(fontRef);</span><br><span class="line"></span><br><span class="line">textLayer<span class="variable">.string</span> = <span class="string">@"sgladgka"</span>;</span><br></pre></td></tr></table></figure>
<p>CATextLayer的font属性不是一个UIFont类型，而是一个CFTypeRef类型。这样可以根据你的具体需要来决定字体属性应该是用CGFontRef类型还是CTFontRef类型(Core Text字体)。同时字体大小也是用fontSize属性单独设置的，因为CTFontRef和CGFontRef并不像UIFont一样包含点大小。</p>
<p>另外，CATextLayer和string属性并不是你想象的NSString类型，而是id类型。这样你既可以用NSString也可以用NSAttributedString来指定文本了(NSAttributedString并不是NSString的子类)。属性化字符串是iOS用来渲染字体风格的机制，它以特定的方式来决定指定范围内的字符串的原始信息，比如字体、颜色、字重、斜体等。</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/04/11/iOS-Core-Animation——动画/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          iOS Core Animation——动画
        
      </div>
    </a>
  
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="iOS-Core-Animation——图层" data-title="iOS Core Animation——图层" data-url="http://yoursite.com/2016/04/11/iOS-Core-Animation——图层/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 John
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>